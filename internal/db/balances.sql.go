// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: balances.sql

package db

import (
	"context"

	"github.com/AlphaByte02/FairSplit/internal/types"
	"github.com/google/uuid"
)

const getIntermediateBalances = `-- name: GetIntermediateBalances :many
SELECT
    /* sql-formatter-disable */
    t.id, t.session_id, t.payer_id, t.amount, t.description, t.created_at, t.updated_at,
    payer.id, payer.username, payer.created_at, payer.updated_at,
    dep.id, dep.username, dep.created_at, dep.updated_at,
    /* sql-formatter-enable */
    (
        t.amount / COUNT(tp.*) OVER (
            PARTITION BY
                t.id
        )
    )::numeric(12, 2) AS amount_per_user
FROM
    transactions t
    LEFT JOIN users payer ON t.payer_id = payer.id
    LEFT JOIN transaction_participants tp ON tp.transaction_id = t.id
    LEFT JOIN users dep ON dep.id = tp.user_id
WHERE
    t.session_id = $1
ORDER BY
    t.id
`

type GetIntermediateBalancesRow struct {
	Transaction   Transaction   `json:"transaction"`
	User          User          `json:"user"`
	User_2        User          `json:"user_2"`
	AmountPerUser types.Numeric `json:"amount_per_user"`
}

func (q *Queries) GetIntermediateBalances(ctx context.Context, sessionID uuid.UUID) ([]GetIntermediateBalancesRow, error) {
	rows, err := q.db.Query(ctx, getIntermediateBalances, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIntermediateBalancesRow
	for rows.Next() {
		var i GetIntermediateBalancesRow
		if err := rows.Scan(
			&i.Transaction.ID,
			&i.Transaction.SessionID,
			&i.Transaction.PayerID,
			&i.Transaction.Amount,
			&i.Transaction.Description,
			&i.Transaction.CreatedAt,
			&i.Transaction.UpdatedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User_2.ID,
			&i.User_2.Username,
			&i.User_2.CreatedAt,
			&i.User_2.UpdatedAt,
			&i.AmountPerUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionBalances = `-- name: GetSessionBalances :many
WITH
    tx_info AS (
        SELECT
            id,
            amount,
            (
                SELECT
                    COUNT(*)
                FROM
                    transaction_participants tp
                WHERE
                    tp.transaction_id = t.id
            ) AS num_parts
        FROM
            transactions t
        WHERE
            t.session_id = $1
    ),
    paid AS (
        SELECT
            t.payer_id AS user_id,
            SUM(t.amount) AS total_paid
        FROM
            transactions t
        WHERE
            t.session_id = $1
        GROUP BY
            t.payer_id
    ),
    consumed AS (
        SELECT
            tp.user_id,
            SUM(tx.amount / tx.num_parts::numeric) AS total_consumed
        FROM
            transaction_participants tp
            JOIN tx_info tx ON tx.id = tp.transaction_id
        GROUP BY
            tp.user_id
    ),
    balances AS (
        SELECT
            sp.user_id,
            CAST(COALESCE(p.total_paid, 0) - COALESCE(c.total_consumed, 0) AS numeric(12, 2)) AS balance
        FROM
            session_participants sp
            LEFT JOIN paid p ON p.user_id = sp.user_id
            LEFT JOIN consumed c ON c.user_id = sp.user_id
        WHERE
            sp.session_id = $1
    )
SELECT
    /* sql-formatter-disable */
    u.id, u.username, u.created_at, u.updated_at,
    /* sql-formatter-enable */
    b.balance
FROM
    balances b
    LEFT JOIN users u ON b.user_id = u.id
`

type GetSessionBalancesRow struct {
	User    User          `json:"user"`
	Balance types.Numeric `json:"balance"`
}

func (q *Queries) GetSessionBalances(ctx context.Context, sessionID uuid.UUID) ([]GetSessionBalancesRow, error) {
	rows, err := q.db.Query(ctx, getSessionBalances, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionBalancesRow
	for rows.Next() {
		var i GetSessionBalancesRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Username,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.Balance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
