// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: balances.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getFinalBalancesBySession = `-- name: GetFinalBalancesBySession :many
SELECT
    fb.id, fb.session_id, fb.creditor_id, fb.debtor_id, fb.amount, fb.is_paid, fb.created_at, fb.updated_at,
    /* sql-formatter-disable */
    cred.id, cred.email, cred.username, cred.picture, cred.paypal_username, cred.iban, cred.created_at, cred.updated_at,
    debt.id, debt.email, debt.username, debt.picture, debt.paypal_username, debt.iban, debt.created_at, debt.updated_at
    /* sql-formatter-enable */
FROM
    final_balances fb
    LEFT JOIN users cred ON fb.creditor_id = cred.id
    LEFT JOIN users debt ON fb.debtor_id = debt.id
WHERE
    session_id = $1
`

type GetFinalBalancesBySessionRow struct {
	ID         uuid.UUID          `json:"id"`
	SessionID  uuid.UUID          `json:"session_id"`
	CreditorID uuid.UUID          `json:"creditor_id"`
	DebtorID   uuid.UUID          `json:"debtor_id"`
	Amount     decimal.Decimal    `json:"amount"`
	IsPaid     bool               `json:"is_paid"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	User       User               `json:"user"`
	User_2     User               `json:"user_2"`
}

func (q *Queries) GetFinalBalancesBySession(ctx context.Context, sessionID uuid.UUID) ([]GetFinalBalancesBySessionRow, error) {
	rows, err := q.db.Query(ctx, getFinalBalancesBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFinalBalancesBySessionRow
	for rows.Next() {
		var i GetFinalBalancesBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.CreditorID,
			&i.DebtorID,
			&i.Amount,
			&i.IsPaid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.Picture,
			&i.User.PaypalUsername,
			&i.User.Iban,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User_2.ID,
			&i.User_2.Email,
			&i.User_2.Username,
			&i.User_2.Picture,
			&i.User_2.PaypalUsername,
			&i.User_2.Iban,
			&i.User_2.CreatedAt,
			&i.User_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIntermediateBalances = `-- name: GetIntermediateBalances :many
SELECT
    /* sql-formatter-disable */
    t.id, t.session_id, t.payer_id, t.amount, t.description, t.created_by_id, t.created_at, t.updated_at,
    payer.id, payer.email, payer.username, payer.picture, payer.paypal_username, payer.iban, payer.created_at, payer.updated_at,
    dep.id, dep.email, dep.username, dep.picture, dep.paypal_username, dep.iban, dep.created_at, dep.updated_at,
    /* sql-formatter-enable */
    (
        t.amount / COUNT(tp.*) OVER (
            PARTITION BY
                t.id
        )
    )::numeric(12, 2) AS amount_per_user
FROM
    transactions t
    LEFT JOIN users payer ON t.payer_id = payer.id
    LEFT JOIN transaction_participants tp ON tp.transaction_id = t.id
    LEFT JOIN users dep ON dep.id = tp.user_id
WHERE
    t.session_id = $1
ORDER BY
    t.id
`

type GetIntermediateBalancesRow struct {
	Transaction   Transaction     `json:"transaction"`
	User          User            `json:"user"`
	User_2        User            `json:"user_2"`
	AmountPerUser decimal.Decimal `json:"amount_per_user"`
}

func (q *Queries) GetIntermediateBalances(ctx context.Context, sessionID uuid.UUID) ([]GetIntermediateBalancesRow, error) {
	rows, err := q.db.Query(ctx, getIntermediateBalances, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIntermediateBalancesRow
	for rows.Next() {
		var i GetIntermediateBalancesRow
		if err := rows.Scan(
			&i.Transaction.ID,
			&i.Transaction.SessionID,
			&i.Transaction.PayerID,
			&i.Transaction.Amount,
			&i.Transaction.Description,
			&i.Transaction.CreatedByID,
			&i.Transaction.CreatedAt,
			&i.Transaction.UpdatedAt,
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.Picture,
			&i.User.PaypalUsername,
			&i.User.Iban,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User_2.ID,
			&i.User_2.Email,
			&i.User_2.Username,
			&i.User_2.Picture,
			&i.User_2.PaypalUsername,
			&i.User_2.Iban,
			&i.User_2.CreatedAt,
			&i.User_2.UpdatedAt,
			&i.AmountPerUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionBalances = `-- name: GetSessionBalances :many
WITH
    tx_info AS (
        SELECT
            id,
            amount,
            (
                SELECT
                    COUNT(*)
                FROM
                    transaction_participants tp
                WHERE
                    tp.transaction_id = t.id
            ) AS num_parts
        FROM
            transactions t
        WHERE
            t.session_id = $1
    ),
    paid AS (
        SELECT
            t.payer_id AS user_id,
            SUM(t.amount) AS total_paid
        FROM
            transactions t
        WHERE
            t.session_id = $1
        GROUP BY
            t.payer_id
    ),
    consumed AS (
        SELECT
            tp.user_id,
            SUM(tx.amount / tx.num_parts::numeric) AS total_consumed
        FROM
            transaction_participants tp
            JOIN tx_info tx ON tx.id = tp.transaction_id
        GROUP BY
            tp.user_id
    ),
    balances AS (
        SELECT
            sp.user_id,
            CAST(COALESCE(p.total_paid, 0) - COALESCE(c.total_consumed, 0) AS numeric(12, 2)) AS balance
        FROM
            session_participants sp
            LEFT JOIN paid p ON p.user_id = sp.user_id
            LEFT JOIN consumed c ON c.user_id = sp.user_id
        WHERE
            sp.session_id = $1
    )
SELECT
    /* sql-formatter-disable */
    u.id, u.email, u.username, u.picture, u.paypal_username, u.iban, u.created_at, u.updated_at,
    /* sql-formatter-enable */
    b.balance
FROM
    balances b
    LEFT JOIN users u ON b.user_id = u.id
`

type GetSessionBalancesRow struct {
	User    User            `json:"user"`
	Balance decimal.Decimal `json:"balance"`
}

func (q *Queries) GetSessionBalances(ctx context.Context, sessionID uuid.UUID) ([]GetSessionBalancesRow, error) {
	rows, err := q.db.Query(ctx, getSessionBalances, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionBalancesRow
	for rows.Next() {
		var i GetSessionBalancesRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Email,
			&i.User.Username,
			&i.User.Picture,
			&i.User.PaypalUsername,
			&i.User.Iban,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.Balance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDeptPaid = `-- name: SetDeptPaid :exec
UPDATE final_balances
SET
    is_paid = TRUE
WHERE
    id = $1
`

func (q *Queries) SetDeptPaid(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setDeptPaid, id)
	return err
}
